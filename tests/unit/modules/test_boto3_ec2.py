# Import Python libs
# Note on testing errorhandling:
# Since boto3_ec2 does't influence what the contents of the error is, it shouldn't be tested
# because if boto3 changes the errormessage, these tests will suddenly start failing
# without any changes to boto3_ec2.
# Only the errormessages generated by boto3_ec2 are validated.

import inspect
import logging

# pylint: disable=3rd-party-module-not-gated
import pkg_resources
from pkg_resources import DistributionNotFound

# Import Salt libs
import salt.config
import salt.loader
import salt.modules.boto3_ec2 as boto3_ec2
import salt.modules.boto3_generic as boto3_generic
import salt.utils.boto3mod
import salt.utils.data
from salt.exceptions import SaltInvocationError

# Import 3rd-party libs
# pylint: disable=import-error
from salt.utils.versions import LooseVersion

# Import Salt Testing libs
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch  # pylint: disable=unused-import
from tests.support.runtests import RUNTIME_VARS  # pylint: disable=unused-import
from tests.support.unit import TestCase, skipIf

# pylint: enable=3rd-party-module-not-gated


# pylint: disable=no-name-in-module,unused-import
try:
    import boto3
    import botocore
    from botocore.exceptions import ClientError

    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False

try:
    import moto
    import moto.ec2.responses
    from moto import mock_ec2

    # Add mocks for functions not implemented in moto
    # mocked_functions = {
    #    'describe_vpcs': MagicMock(return_value={'Vpcs': [{'VpcId': 'vpc-12345678'}]}),
    #    'describe_subnets': MagicMock(return_value={'Subnets': [{'SubnetId': 'subnet-12345678'}]}),
    #    'describe_customer_gateways': MagicMock(return_value={'CustomerGateways': [{'CustomerGatewayId': 'cgw-12345678'}]}),
    #    'describe_network_acls': MagicMock(return_value={'NetworkAcls': [{'NetworkAclId': 'acl-12345678'}]}),
    # }
    # for function_name, mock_function in mocked_functions.items():
    #    if not hasattr(moto.ec2.ec2_backend, function_name):
    #        setattr(moto.ec2.ec2_backend, function_name, mock_function)

    HAS_MOTO = True
except ImportError:
    HAS_MOTO = False

    def mock_ec2():
        """
        if the mock_ec2 function is not available due to import failure
        this replaces the decorated function with stub_function.
        Allows boto3_ec2 unit tests to use the @mock_ec2 decorator
        without a "NameError: name 'mock_ec2' is not defined" error.
        """

        def stub_function():
            pass

        return stub_function


log = logging.getLogger(__name__)
# pylint: enable=import-error,no-name-in-module,unused-import
required_boto_version = "1.13.0"
required_moto_version = "1.0.0"

region = "us-east-1"
access_key = "GKTADJGHEIQSXMKKRBJ08H"
secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
boto3_conn_parameters = {
    "region_name": region,
    "aws_access_key_id": access_key,
    "aws_secret_access_key": secret_key,
}
salt_conn_parameters = {
    "region": region,
    "key": access_key,
    "keyid": secret_key,
    "profile": {},
}
dhcp_options_parameters = {
    "domain_name": "example.com",
    "domain_name_servers": ["1.2.3.4"],
    "ntp_servers": ["5.6.7.8"],
    "netbios_name_servers": ["10.0.0.1"],
    "netbios_node_type": 2,
}


def _has_required_boto():
    """
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    """
    if not HAS_BOTO:
        return False
    if LooseVersion(boto3.__version__) < LooseVersion(required_boto_version):
        return False
    return True


def _get_boto_version():
    """
    Returns the boto version
    """
    if not HAS_BOTO:
        return False
    return LooseVersion(boto3.__version__)


def _get_moto_version():
    """
    Returns the moto version
    """
    try:
        return LooseVersion(str(moto.__version__))
    except AttributeError:
        try:
            return LooseVersion(pkg_resources.get_distribution("moto").version)
        except DistributionNotFound:
            return False


def _has_required_moto():
    """
    Returns True/False boolean depending on if Moto is installed and correct
    version.
    """
    if not HAS_MOTO or _get_moto_version() < LooseVersion(required_moto_version):
        return False
    return True


def _moto_cannot(*args):
    """
    Checks whether moto implements the specified functions in the ec2 backend.
    Used as argument with skipIf to dynamically skip tests if moto does not
    implement any of the boto3 functions used in the test.

    :param str *args: One or more (boto3) function names to check.
    :rtype: (bool, str)
    :return: True if any of the functions are not implemented
        False if all functions are implemented
        The returned string lists the functions that are not implemented.
    """
    not_implemented = [
        item
        for item in args
        if not (
            hasattr(moto.ec2.ec2_backend, item)
            or hasattr(moto.ec2.responses.EC2Response, item)
        )
    ]
    return (
        bool(not_implemented),
        "Moto does not implement: {}".format(", ".join(not_implemented)),
    )


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version() if HAS_BOTO else "None"
    ),
)
@skipIf(
    _has_required_moto() is False,
    "The moto version must be >= to version {}. Installed: {}".format(
        required_moto_version, _get_moto_version() if HAS_MOTO else "None"
    ),
)
class BotoVpcTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn3 = None

    def setup_loader_modules(self):
        self.opts = opts = salt.config.DEFAULT_MINION_OPTS.copy()
        utils = salt.loader.utils(
            opts,
            whitelist=["boto", "boto3"],
        )
        wanted_modules = {}
        for function_name, function in inspect.getmembers(
            boto3_ec2, inspect.isfunction
        ):
            wanted_modules.update({"boto3_ec2.{}".format(function_name): function})
        for function_name, function in inspect.getmembers(
            boto3_generic, inspect.isfunction
        ):
            wanted_modules.update({"boto3_generic.{}".format(function_name): function})
        ret = {
            boto3_ec2: {"__utils__": utils, "__salt__": wanted_modules},
            boto3_generic: {"__salt__": wanted_modules},
        }
        return ret

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.cidr_block = "10.0.0.0/16"

        cls.network_acl_entry_parameters = {
            "network_acl_id": "fake",
            "rule_number": 100,
            "protocol": "-1",
            "rule_action": "allow",
            "cidr_block": cls.cidr_block,
            "egress": True,
        }
        cls.mock_error = {"Error": {"Code": "Mock", "Message": "Mocked error"}}
        cls.mock_errormessage = (
            "An error occurred (Mock) when calling the {} operation: Mocked error"
        )

    def setUp(self):
        super().setUp()
        self.opts = salt.config.DEFAULT_MINION_OPTS.copy()
        boto3_ec2.__init__(self.opts)
        delattr(self, "opts")

    def test_dummy(self):
        pass


class BotoVpcTestCaseMixin:
    """
    Helper class that contains methods for setting up cloud components using boto3
    directly instead of using boto3_ec2.
    """

    conn = None
    ec2 = None

    def _create_tags(self, resource_id, tags=None):
        """
        Helper function to create tags on a resource
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)
        params = {
            "Resources": [resource_id],
            "Tags": [{"Key": k, "Value": v} for k, v in tags.items()],
        }
        self.conn.create_tags(**params)

    def _create_vpc(self, name=None, tags=None, cidr_block=None, ipv6=None):
        """
        Helper function to create a test vpc

        Note that moto 1.3.14 does not support TagSpecification on create, so we
        will need to call create_tags separately.
        """
        if cidr_block is None:
            cidr_block = self.cidr_block
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)
        if tags is None:
            tags = {}
        if name is not None:
            tags.update({"Name": name})
        params = salt.utils.data.filter_falsey(
            {
                "CidrBlock": cidr_block,
                "AmazonProvidedIpv6CidrBlock": ipv6,
            }
        )
        res = self.conn.create_vpc(**params)
        vpc_id = res["Vpc"]["VpcId"]
        self._create_tags(vpc_id, tags)
        return vpc_id

    def _create_subnet(
        self,
        vpc_id,
        cidr_block="10.0.0.0/25",
        name=None,
        tags=None,
        availability_zone=None,
    ):
        """
        Helper function to create a test subnet
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)
        if tags is None:
            tags = {}
        if name is not None:
            tags.update({"Name": name})
        params = salt.utils.data.filter_falsey(
            {
                "AvailabilityZone": availability_zone,
                "CidrBlock": cidr_block,
                "VpcId": vpc_id,
            },
            recurse_depth=1,
        )
        res = self.conn.create_subnet(**params)
        subnet_id = res["Subnet"]["SubnetId"]
        self._create_tags(subnet_id, tags)
        return subnet_id

    def _create_internet_gateway(self, vpc_id, name=None, tags=None):
        """
        Helper function to create a test internet gateway
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)

        if tags is None:
            tags = {}
        if name is not None:
            tags.update({"Name": name})

        res = self.conn.create_internet_gateway(VpcId=vpc_id)
        igw_id = res["InternetGateway"]["InternetGatewayId"]
        self._create_tags(igw_id, tags)
        return igw_id

    def _create_customer_gateway(self, vpc_id, name=None, tags=None):
        """
        Helper function to create a test customer gateway
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)

        if tags is None:
            tags = {}
        if name is not None:
            tags.update({"Name": name})
        params = salt.utils.data.filter_falsey({"VpcId": vpc_id}, recurse_depth=1)

        res = self.conn.create_customer_gateway(**params)
        cgw_id = res["CustomerGateway"]["CustomerGatewayId"]
        self._create_tags(cgw_id, tags)
        return cgw_id

    def _create_dhcp_options(
        self,
        domain_name="example.com",
        domain_name_servers=None,
        ntp_servers=None,
        netbios_name_servers=None,
        netbios_node_type="2",
    ):
        """
        Helper function to create test dchp options
        """
        if not netbios_name_servers:
            netbios_name_servers = ["10.0.0.1"]
        if not ntp_servers:
            ntp_servers = ["5.6.7.8"]
        if not domain_name_servers:
            domain_name_servers = ["1.2.3.4"]

        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)

        res = self.conn.create_dhcp_options(
            DhcpConfigurations=[
                {"Key": "domain-name", "Values": [domain_name]},
                {"Key": "domain-name-server", "Values": domain_name_servers},
                {"Key": "ntp-servers", "Values": ntp_servers},
                {"Key": "netbios-name-servers", "Values": netbios_name_servers},
                {"Key": "netbios-node-type", "Values": [netbios_node_type]},
            ]
        )
        return res["DhcpOptions"]["DhcpOptionsId"]

    def _create_network_acl(self, vpc_id, tags=None):
        """
        Helper function to create test network acl
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)
        if tags is None:
            tags = {}
        res = self.conn.create_network_acl(VpcId=vpc_id)
        network_acl_id = res["NetworkAcl"]["NetworkAclId"]
        self._create_tags(network_acl_id, tags)
        return network_acl_id

    def _create_network_acl_entry(
        self,
        network_acl_id=None,
        rule_number=None,
        protocol=None,
        rule_action=None,
        cidr_block=None,
        egress=None,
        icmp_code=None,
        icmp_type=None,
        port_range_from=None,
        port_range_to=None,
    ):
        """
        Helper function to create test network acl entry
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)

        params = salt.utils.data.filter_falsey(
            {
                "NetworkAclId": network_acl_id,
                "RuleNumber": rule_number,
                "Protocol": protocol,
                "RuleAction": rule_action,
                "CidrBlock": cidr_block,
                "Egress": egress,
                "IcmpTypeCode": {"Code": icmp_code, "Type": icmp_type},
                "PortRange": {"From": port_range_from, "To": port_range_to},
            },
            recurse_depth=1,
        )

        return self.conn.create_network_acl_entry(**params)

    def _create_route_table(self, vpc_id, name=None, tags=None):
        """
        Helper function to create a test route table
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)

        if tags is None:
            tags = {}
        if name is not None:
            tags.update({"Name": name})
        params = salt.utils.data.filter_falsey({"VpcId": vpc_id}, recurse_depth=1)

        res = self.conn.create_route_table(**params)
        route_table_id = res["RouteTable"]["RouteTableId"]
        self._create_tags(route_table_id, tags)
        return route_table_id

    def _associate_route_table(self, route_table_id, subnet_id):
        """
        Helper function to associate a route table to a subnet.
        """
        if not self.conn:
            self.conn = boto3.client("ec2", **boto3_conn_parameters)
        res = self.conn.associate_route_table(
            RouteTableId=route_table_id,
            SubnetId=subnet_id,
        )
        return res["AssociationId"]


class BotoVpcTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    """
    TestCase for salt.modules.boto3_ec2 module, VPC related operations.
    """

    #  describe_vpcs tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_describe_vpcs_without_filters_returns_all_vpcs(self):
        """
        Test that describe_vpcs without filters returns all VPCs.
        """
        self._create_vpc()
        res = boto3_ec2.describe_vpcs(**salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual(len(res["result"]), 2)  # Default VPC and created VPC

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_describe_existing_vpc_by_id_returns_it(
        self,
    ):
        """
        Tests describing existing VPC by ID returns it.
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.describe_vpcs(vpc_ids=vpc_id, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertIn("VpcId", res["result"][0])
        self.assertEqual(res["result"][0]["VpcId"], vpc_id)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpcs"))
    def test_describe_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests describing non-existing VPC by ID returns an error.
        """
        res = boto3_ec2.describe_vpcs(vpc_ids="fake", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertIn("VpcID {'fake'} does not exist.", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_describe_existing_vpc_returns_dict_of_properties(
        self,
    ):
        """
        Tests describing parameters via vpc id if vpc exist
        """
        # With moto 0.4.25 through 0.4.30, is_default is set to True.
        # 0.4.24 and older and 0.4.31 and newer, is_default is False
        is_default = (
            LooseVersion("0.4.25") <= _get_moto_version() < LooseVersion("0.4.31")
        )
        vpc_id = self._create_vpc(name="test", tags={"test": "testvalue"})

        res = boto3_ec2.describe_vpcs(vpc_ids=vpc_id, **salt_conn_parameters)
        # Check specific individual properties as newer versions of moto might return more
        self.assertIn("result", res)
        self.assertEqual(len(res["result"]), 1)
        self.assertEqual(res["result"][0]["VpcId"], vpc_id)
        self.assertEqual(res["result"][0]["CidrBlock"], self.cidr_block)
        self.assertEqual(res["result"][0]["IsDefault"], is_default)
        self.assertEqual(res["result"][0]["State"], "available")
        self.assertEqual(res["result"][0]["DhcpOptionsId"], "dopt-7a8b9c2d")
        self.assertEqual(res["result"][0]["InstanceTenancy"], "default")
        self.assertEqual(
            res["result"][0]["Tags"],
            [{"Key": "test", "Value": "testvalue"}, {"Key": "Name", "Value": "test"}],
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_describe_vpcs_correctly_handles_forced_error(self):
        """
        Tests describing parameters failure
        """
        vpc_id = self._create_vpc(name="test", tags={"test": "testvalue"})

        patch_function = "get_all_vpcs"
        with patch(
            "moto.ec2.ec2_backend.{}".format(patch_function),
            side_effect=ClientError(self.mock_error, patch_function),
        ):
            res = boto3_ec2.describe_vpcs(vpc_ids=vpc_id, **salt_conn_parameters)
        self.assertEqual(res, {"error": self.mock_errormessage.format(patch_function)})

    # lookup_vpc tests
    @mock_ec2
    def test_lookup_vpc_without_arguments_raises_error(
        self,
    ):
        """
        Tests looking up VPC without arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "No constraints where given for lookup_vpc.",
        ):
            boto3_ec2.lookup_vpc(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_lookup_existing_vpc_by_id_returns_it(
        self,
    ):
        """
        Tests looking up a VPC by id when it does indeed exist.
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.lookup_vpc(vpc_id=vpc_id, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual(res["result"]["VpcId"], vpc_id)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpcs"))
    def test_lookup_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests describing non-existing VPC by ID returns an error.
        """
        res = boto3_ec2.lookup_vpc(vpc_id="fake", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_lookup_existing_vpc_by_name_tag_returns_it(
        self,
    ):
        """
        Tests looking up a VPC via name when VPC exists.
        """
        vpc_id = self._create_vpc(name="test")
        res = boto3_ec2.lookup_vpc(vpc_name="test", **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual(res["result"]["VpcId"], vpc_id)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpcs"))
    def test_lookup_non_existing_vpc_by_name_tag_returns_error(
        self,
    ):
        """
        Tests looking up a VPC via name when VPC does not exist.
        """
        res = boto3_ec2.lookup_vpc(vpc_name="test", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_lookup_existing_vpc_by_custom_tag_returns_it(
        self,
    ):
        """
        Tests looking up a VPC via custom tag when VPC exists.
        """
        vpc_id = self._create_vpc(tags={"test": "testvalue"})
        res = boto3_ec2.lookup_vpc(tags={"test": "testvalue"}, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual(res["result"]["VpcId"], vpc_id)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpcs"))
    def test_lookup_non_existing_vpc_by_custom_tag_returns_error(
        self,
    ):
        """
        Tests looking up a VPC via custom tag when VPC does not exist.
        """
        res = boto3_ec2.lookup_vpc(tags={"test": "testvalue"}, **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])
        self.assertIn("result", res)
        self.assertEqual({}, res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_lookup_existing_vpc_by_cidr_returns_it(
        self,
    ):
        """
        Tests looking up a VPC via CIDR when VPC exists.
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.lookup_vpc(cidr="10.0.0.0/16", **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual(res["result"]["VpcId"], vpc_id)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpcs"))
    def test_lookup_non_existing_vpc_by_cidr_returns_error(
        self,
    ):
        """
        Tests looking up a VPC via CIDR when VPC does not exist.
        """
        res = boto3_ec2.lookup_vpc(cidr="10.10.10.10/24", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpcs"))
    def test_lookup_vpc_resulting_in_multiple_matches_returns_error(
        self,
    ):
        """
        Tests lookup_vpc returns error when multiple VPCs match.
        """
        self._create_vpc(name="vpc-test1")
        self._create_vpc(name="vpc-test2")
        res = boto3_ec2.lookup_vpc(cidr="10.0.0.0/16", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual(
            "There are multiple vpcs with the specified filters. Please specify additional filters.",
            res["error"],
        )

    # create_vpc tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc"))
    def test_that_when_creating_a_vpc_succeeds_the_create_vpc_method_returns_true(self):
        """
        tests True VPC created.
        """
        res = boto3_ec2.create_vpc(self.cidr_block, **salt_conn_parameters)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc"))
    def test_that_when_creating_a_vpc_and_specifying_a_vpc_name_succeeds_the_create_vpc_method_returns_true(
        self,
    ):
        """
        tests True VPC created.
        """
        res = boto3_ec2.create_vpc(
            self.cidr_block, tags={"Name": "test"}, **salt_conn_parameters
        )
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc"))
    def test_that_when_creating_a_vpc_fails_the_create_vpc_method_returns_error(self):
        """
        tests False VPC not created.
        """
        patch_function = "create_vpc"
        with patch(
            "moto.ec2.ec2_backend.{}".format(patch_function),
            side_effect=ClientError(self.mock_error, patch_function),
        ):
            res = boto3_ec2.create_vpc(self.cidr_block, **salt_conn_parameters)
        self.assertEqual(res, {"error": self.mock_errormessage.format(patch_function)})

    # delete_vpc tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "delete_vpc"))
    def test_that_when_deleting_an_existing_vpc_the_delete_vpc_method_returns_true(
        self,
    ):
        """
        Tests deleting an existing vpc
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.delete_vpc(vpc_id, **salt_conn_parameters)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("delete_vpc"))
    def test_that_when_deleting_a_non_existent_vpc_the_delete_vpc_method_returns_error(
        self,
    ):
        """
        Tests deleting a non-existent vpc
        """
        res = boto3_ec2.delete_vpc("1234", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertIn("VpcID 1234 does not exist.", res["error"])

    # describe_vpc_attribute tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpc_attribute"))
    def test_describe_vpc_attribute(self):
        """
        Tests describing a VPC attribute
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.describe_vpc_attribute(
            attributes="enable_dns_support", vpc_id=vpc_id, **salt_conn_parameters
        )

        self.assertIn("result", res)
        self.assertEqual({"enable_dns_support": True}, res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpc_attribute"))
    def test_describe_multiple_vpc_attributes(self):
        """
        Tests describing multiple VPC attributes in one call.
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.describe_vpc_attribute(
            attributes=["enable_dns_support", "enable_dns_hostnames"],
            vpc_id=vpc_id,
            **salt_conn_parameters
        )

        self.assertIn("result", res)
        self.assertEqual(
            {"enable_dns_support": True, "enable_dns_hostnames": False}, res["result"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpc_attribute"))
    def test_describe_vpc_attribute_with_incorrect_attribute_returns_error(self):
        """
        Tests describing an incorrect VPC attribute.
        """
        vpc_id = self._create_vpc()
        res = boto3_ec2.describe_vpc_attribute(
            attributes="nope", vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("error", res)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpc_attribute"))
    def test_describe_vpc_attribute_with_non_existing_vpc_returns_error(self):
        """
        Tests describing a VPC attribute for a non-existing VPC.
        """
        res = boto3_ec2.describe_vpc_attribute(
            attributes="enable_dns_support", vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)

    # modify_vpc_attribute tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_modify_vpc_attribute_without_arguments_raises_error(
        self,
    ):
        """
        Tests modify_vpc_attribute without arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.modify_vpc_attribute(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("modify_vpc_attribute"))
    def test_modify_vpc_attribute_on_non_existing_vpc_returns_error(
        self,
    ):
        """
        Tests errorhandling when calling modify_vpc_attribute with a non-existing vpc_id.
        """
        res = boto3_ec2.modify_vpc_attribute(
            vpc_id="fake", enable_dns_support=False, **salt_conn_parameters
        )
        self.assertIn("error", res)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "modify_vpc_attribute"))
    def test_modify_multiple_vpc_attributes_by_id_in_one_call_returns_true_and_modifies_attributes(
        self,
    ):
        """
        Tests modifying multiple VPC attributes in one call and verifying the attributes changed.
        VPC is targetd by ID.
        """
        vpc_id = self._create_vpc()
        old_values = boto3_ec2.describe_vpc_attribute(
            attributes=["enable_dns_support", "enable_dns_hostnames"],
            vpc_id=vpc_id,
            **salt_conn_parameters
        )
        self.assertIn("result", old_values)
        self.assertEqual(
            {"enable_dns_support": True, "enable_dns_hostnames": False},
            old_values["result"],
        )

        res = boto3_ec2.modify_vpc_attribute(
            vpc_id=vpc_id,
            enable_dns_support=False,
            enable_dns_hostnames=True,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertTrue(res["result"])

        new_values = boto3_ec2.describe_vpc_attribute(
            attributes=["enable_dns_support", "enable_dns_hostnames"],
            vpc_id=vpc_id,
            **salt_conn_parameters
        )
        self.assertIn("result", new_values)
        # Interestingly enough, this shouldn't be allowed, since enable_dns_hostnames
        # depends on enable_dns_support (it explicitly says so in the function docstring).
        # Probably a bug in moto :)
        self.assertEqual(
            {"enable_dns_support": False, "enable_dns_hostnames": True},
            new_values["result"],
        )

    # enable_vpc_classic_link tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_enable_vpc_classic_link_without_parameters_raises_error(
        self,
    ):
        """
        Tests call to enable_vpc_classic_link without supplying targeting parameters.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.enable_vpc_classic_link(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("enable_vpc_classic_link"))
    def test_enable_vpc_classic_link_on_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests call to enable_vpc_classic_link targetting a non_existing VPC by ID fails.
        """
        res = boto3_ec2.enable_vpc_classic_link(vpc_id="fake", **salt_conn_parameters)
        self.assertIn("error", res)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "enable_vpc_classic_link"))
    def test_enable_vpc_classic_link_on_existing_vpc_by_id_returns_true(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link targetting the VPC by ID.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "enable_vpc_classic_link", "describe_vpcs"))
    def test_enable_vpc_classic_link_on_existing_vpc_by_lookup_returns_true(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link targetting the VPC by name.
        """
        self._create_vpc(name="test")

        res = boto3_ec2.enable_vpc_classic_link(
            vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertTrue(res["result"])

    # describe_vpc_classic_link tests
    @mock_ec2
    def test_describe_vpc_classic_link_without_arguments_raises_error(
        self,
    ):
        """
        Tests describe_vpc_classic_link without targeting arguments.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.describe_vpc_classic_link(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpc_classic_link"))
    def test_describe_vpc_classic_link_on_existing_vpc_by_id_without_classic_link_returns_disabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link on a VPC (by ID) with classic link disabled.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.describe_vpc_classic_link(
            vpc_ids=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkEnabled": False, "VpcId": vpc_id}]}, res["result"]
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "enable_vpc_classic_link", "describe_vpc_classic_link"
        )
    )
    def test_describe_vpc_classic_link_on_existing_vpc_by_id_with_classic_link_enabled_returns_enabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link on a VPC (by ID) with classic link enabled.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.describe_vpc_classic_link(
            vpc_ids=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkEnabled": True, "VpcId": vpc_id}]}, res["result"]
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "describe_vpc_classic_link",
            "describe_vpcs",
        )
    )
    def test_describe_vpc_classic_link_on_existing_vpc_by_lookup_with_classic_link_enabled_returns_enabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link on a VPC (by Name-tag) with classic link enabled.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.describe_vpc_classic_link(
            vpc_lookups={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkEnabled": True, "VpcId": vpc_id}]}, res["result"]
        )

    # disable_vpc_classic_link tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_disable_vpc_classic_link_without_arguments_raises_error(
        self,
    ):
        """
        Tests call to disable_vpc_classic_link without targetting parameters.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.disable_vpc_classic_link(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("disable_vpc_classic_link"))
    def test_disable_vpc_classic_link_on_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests call to disable_vpc_classic_link targetting a non_existing VPC by ID fails.
        """
        res = boto3_ec2.disable_vpc_classic_link(vpc_id="fake", **salt_conn_parameters)
        self.assertIn("error", res)

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "enable_vpc_classic_link", "disable_vpc_classic_link"
        )
    )
    def test_enable_and_disable_vpc_classic_link_on_existing_vpc_by_id_returns_true(
        self,
    ):
        """
        Tests succesful call to disable_vpc_classic_link targetting the VPC by ID.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.disable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)
        self.assertIn("result", res)
        # self.assertTrue(res['result'])  # bug in Moto: returns False instead

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "disable_vpc_classic_link",
            "describe_vpcs",
        )
    )
    def test_enable_and_disable_vpc_classic_link_on_existing_vpc_by_lookup_returns_true(
        self,
    ):
        """
        Tests succesful call to disable_vpc_classic_link targetting the VPC by Name-tag.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.disable_vpc_classic_link(
            vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        # self.assertTrue(res['result'])  # bug in Moto: returns False instead

    # enable_vpc_classic_link_dns_support tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_enable_vpc_classic_link_dns_support_without_arguments_raises_error(
        self,
    ):
        """
        Tests call to enable_vpc_classic_link_dns_support without targetting parameters.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.disable_vpc_classic_link_dns_support(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("enable_vpc_classic_link_dns_support"))
    def test_enable_vpc_classic_link_dns_support_on_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests call to enable_vpc_classic_link_dns_support targetting non-existing VPC by ID fails.
        """
        res = boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        # self.assertIn('InvalidVpcID.NotFound', res['error'])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "enable_vpc_classic_link_dns_support"))
    def test_enable_vpc_classic_link_dns_support_on_existing_vpc_by_id_without_enabling_classic_link_returns_error(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link_dns_support targetting the VPC by name.
        """
        self._create_vpc(name="test")

        res = boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertTrue(res)
        # self.assertIn('error', res)  # bug in Moto: doesn't check if classic_link is enabled first.

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "enable_vpc_classic_link_dns_support",
        )
    )
    def test_enable_vpc_classic_link_dns_support_on_existing_vpc_by_id_returns_true(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link_dns_support targetting the VPC by ID.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "enable_vpc_classic_link_dns_support",
            "describe_vpcs",
        )
    )
    def test_enable_vpc_classic_link_dns_support_on_existing_vpc_by_lookup_returns_true(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link_dns_support targetting the VPC by name.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertTrue(res["result"])

    # describe_vpc_classic_link_dns_support tests
    @mock_ec2
    def test_describe_vpc_classic_link_dns_support_without_arguments_raises_error(
        self,
    ):
        """
        Tests describe_vpc_classic_link_dns_support without targeting arguments.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.describe_vpc_classic_link_dns_support(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpc_classic_link_dns_support"))
    def test_describe_vpc_classic_link_dns_support_on_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests describe_vpc_classic_link_dns_support on a non-existing VPC (by ID).
        """
        res = boto3_ec2.describe_vpc_classic_link_dns_support(
            vpc_ids="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        # self.assertIn('InvalidVpcID.NotFound', res['error'])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_vpc_classic_link_dns_support"))
    def test_describe_vpc_classic_link_dns_support_on_existing_vpc_by_id_without_classic_link_returns_disabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link_dns_support on a VPC (by ID) with classic link disabled.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.describe_vpc_classic_link_dns_support(
            vpc_ids=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkDnsSupported": False, "VpcId": vpc_id}]},
            res["result"],
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "describe_vpc_classic_link_dns_support",
        )
    )
    def test_describe_vpc_classic_link_dns_support_on_existing_vpc_by_id_with_classic_link_enabled_but_no_dns_support_returns_disabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link_dns_support on a VPC (by ID) with classic link enabled but dns_support not enabled.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.describe_vpc_classic_link_dns_support(
            vpc_ids=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkDnsSupported": False, "VpcId": vpc_id}]},
            res["result"],
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "enable_vpc_classic_link_dns_support",
            "describe_vpc_classic_link_dns_support",
        )
    )
    def test_describe_vpc_classic_link_dns_support_on_existing_vpc_by_id_with_classic_link_dns_support_enabled_returns_enabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link_dns_support on a VPC (by ID) with classic link and dns_support enabled.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)
        boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_id=vpc_id, **salt_conn_parameters
        )

        res = boto3_ec2.describe_vpc_classic_link_dns_support(
            vpc_ids=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkDnsSupported": True, "VpcId": vpc_id}]},
            res["result"],
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "enable_vpc_classic_link_dns_support",
            "describe_vpc_classic_link_dns_support",
        )
    )
    def test_describe_vpc_classic_link_dns_support_on_existing_vpc_by_name_with_classic_link_dns_support_enabled_returns_enabled(
        self,
    ):
        """
        Tests describe_vpc_classic_link_dns_support on a VPC (by Name-tag) with classic link and dns_support enabled.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)
        boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_id=vpc_id, **salt_conn_parameters
        )

        res = boto3_ec2.describe_vpc_classic_link_dns_support(
            vpc_lookups={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(
            {"Vpcs": [{"ClassicLinkDnsSupported": True, "VpcId": vpc_id}]},
            res["result"],
        )

    # disable_vpc_classic_link_dns_support tests
    @mock_ec2
    def test_ddisable_vpc_classic_link_dns_support_without_arguments_raises_error(
        self,
    ):
        """
        Tests disable_vpc_classic_link_dns_support without targeting arguments.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.disable_vpc_classic_link_dns_support(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("disable_vpc_classic_link_dns_support"))
    def test_disable_vpc_classic_link_dns_support_on_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests call to disable_vpc_classic_link_dns_support targetting non-existing VPC by ID fails.
        """
        res = boto3_ec2.disable_vpc_classic_link_dns_support(
            vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        # self.assertIn('InvalidVpcID.NotFound', res['error'])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "enable_vpc_classic_link_dns_support",
            "disable_vpc_classic_link_dns_support",
        )
    )
    def test_enable_then_disable_vpc_classic_link_dns_support_on_existing_vpc_by_id_returns_true(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link_dns_support targetting the VPC by ID.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)
        boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_id=vpc_id, **salt_conn_parameters
        )

        res = boto3_ec2.disable_vpc_classic_link_dns_support(
            vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        # self.assertTrue(res['result'])  # bug in Moto: returns False instead

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "enable_vpc_classic_link",
            "enable_vpc_classic_link_dns_support",
            "disable_vpc_classic_link_dns_support",
            "describe_vpcs",
        )
    )
    def test_enable_then_disable_vpc_classic_link_dns_support_on_existing_vpc_by_lookup_returns_true(
        self,
    ):
        """
        Tests succesful call to enable_vpc_classic_link_dns_support targetting the VPC by ID.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.enable_vpc_classic_link(vpc_id=vpc_id, **salt_conn_parameters)
        boto3_ec2.enable_vpc_classic_link_dns_support(
            vpc_id=vpc_id, **salt_conn_parameters
        )

        res = boto3_ec2.disable_vpc_classic_link_dns_support(
            vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        # self.assertTrue(res['result'])  # bug in Moto: returns False instead

    # associate_vpc_cidr_block tests
    @mock_ec2
    @skipIf(*_moto_cannot("associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_missing_argument_vpc_raises_error(
        self,
    ):
        """
        Tests calling associate_vpc_cidr_block without specifying the required VPC.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.associate_vpc_cidr_block(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_missing_argument_cidr_returns_error(
        self,
    ):
        """
        Tests calling associate_vpc_cidr_block without specifying a CIDR block,
        IPv6 Pool or Amazon_provided_ipv6_cidr_block.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.associate_vpc_cidr_block(vpc_id=vpc_id, **salt_conn_parameters)
        self.assertTrue(res)
        # self.assertIn('error', res)  # Bug in Moto, doesn't validate required arguments.

    @mock_ec2
    @skipIf(*_moto_cannot("associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_with_ipv4_block_to_non_existing_vpc_non_blocking_returns_error(
        self,
    ):
        """
        Tests associate_vpc_cidr_block with a new IPv4 CIDR block to a non-existing VPC.
        Non-blocking variant.
        """
        res = boto3_ec2.associate_vpc_cidr_block(
            vpc_id="fake", cidr_block="10.1.0.0/16", **salt_conn_parameters
        )
        self.assertIn("error", res)
        # self.assertIn('InvalidVpcID.NotFound', res['error'])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_with_ipv4_block_to_existing_vpc_non_blocking_succeeds(
        self,
    ):
        """
        Tests succesful associating a new IPv4 CIDR block to an existing VPC.
        Non-blocking variant.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id, cidr_block="10.1.0.0/16", **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("CidrBlockAssociation", res["result"])
        self.assertEqual(
            "10.1.0.0/16", res["result"]["CidrBlockAssociation"]["CidrBlock"]
        )
        self.assertEqual(
            "associating",
            res["result"]["CidrBlockAssociation"]["CidrBlockState"]["State"],
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_with_ipv4_block_to_existing_vpc_blocking_succeeds(
        self,
    ):
        """
        Tests succesful associating a new IPv4 CIDR block to an existing VPC.
        Blocking variant.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            cidr_block="10.1.0.0/16",
            blocking=True,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("CidrBlockAssociation", res["result"])
        self.assertEqual(
            "10.1.0.0/16", res["result"]["CidrBlockAssociation"]["CidrBlock"]
        )
        self.assertEqual(
            "associated",
            res["result"]["CidrBlockAssociation"]["CidrBlockState"]["State"],
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_with_amazon_provided_ipv6_block_to_existing_vpc_non_blocking_succeeds(
        self,
    ):
        """
        Tests succesful associating a new IPv4 CIDR block to an existing VPC
        Non-blocking variant.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id, amazon_provided_ipv6_cidr_block=True, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Ipv6CidrBlockAssociation", res["result"])
        self.assertTrue(
            res["result"]["Ipv6CidrBlockAssociation"]["Ipv6CidrBlock"].endswith("/56")
        )
        self.assertEqual(
            "associating",
            res["result"]["Ipv6CidrBlockAssociation"]["Ipv6CidrBlockState"]["State"],
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "associate_vpc_cidr_block"))
    def test_associate_vpc_cidr_block_with_amazon_provided_ipv6_block_to_existing_vpc_blocking_succeeds(
        self,
    ):
        """
        Tests succesful associating a new IPv4 CIDR block to an existing VPC
        Blocking variant.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            amazon_provided_ipv6_cidr_block=True,
            blocking=True,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Ipv6CidrBlockAssociation", res["result"])
        self.assertTrue(
            res["result"]["Ipv6CidrBlockAssociation"]["Ipv6CidrBlock"].endswith("/56")
        )
        self.assertEqual(
            "associated",
            res["result"]["Ipv6CidrBlockAssociation"]["Ipv6CidrBlockState"]["State"],
        )

    # disassociate_vpc_cidr_block tests
    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_without_arguments_raises_error(
        self,
    ):
        """
        Tests disassociate_vpc_cidr block correctly raising error if not enough information is provided through arguments.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            'When not providing an association_id, the argument "vpc_lookup" is required.',
        ):
            boto3_ec2.disassociate_vpc_cidr_block(**salt_conn_parameters)

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_without_association_id_and_insufficient_info_in_vpc_lookup_raises_error(
        self,
    ):
        """
        Tests disassociate_vpc_cidr block correctly raising error if vpc_lookup is provided, but no VPC with the specified cidr_block exists.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            'The argument vpc_lookup must contain an entry for either "cidr_block" or "ipv6_cidr_block".',
        ):
            boto3_ec2.disassociate_vpc_cidr_block(
                vpc_lookup={"vpc_id": "fake"}, **salt_conn_parameters
            )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_without_association_id_and_non_existing_cidr_block_in_vpc_lookup_returns_error(
        self,
    ):
        """
        Tests disassociate_vpc_cidr block correctly raising error if vpc_lookup is provided, but without cidr_block or ipv6_cidr_block.
        """
        res = boto3_ec2.disassociate_vpc_cidr_block(
            vpc_lookup={"vpc_id": "fake", "cidr_block": "10.1.0.0/16"},
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            'No IPv4 CIDR block association was found with the information provided in "vpc_lookup".',
            res["error"],
        )

    @mock_ec2
    @skipIf(*_moto_cannot("disassociate_vpc_cidr_block"))
    def test_disassociate_vpc_cidr_block_without_association_id_and_non_existing_ipv6_cidr_block_in_vpc_lookup_returns_error(
        self,
    ):
        """
        Tests disassociate_vpc_cidr block correctly raising error if vpc_lookup is provided, but no VPC with the specified ipv6_cidr_block exists.
        """
        res = boto3_ec2.disassociate_vpc_cidr_block(
            vpc_lookup={"vpc_id": "fake", "ipv6_cidr_block": "::/64"},
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            'No IPv6 CIDR block association was found with the information provided in "vpc_lookup".',
            res["error"],
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv4_block_by_association_id_non_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv4 CIDR block from an existing VPC.
        Non-blocking variant.
        """
        vpc_id = self._create_vpc()
        association_id = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            cidr_block="10.1.0.0/16",
            blocking=True,
            **salt_conn_parameters
        )["result"]["CidrBlockAssociation"]["AssociationId"]

        res = boto3_ec2.disassociate_vpc_cidr_block(
            association_id=association_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv4_block_by_association_id_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv4 CIDR block from an existing VPC by providing the association_id.
        Blocking variant.
        """
        vpc_id = self._create_vpc()
        association_id = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            cidr_block="10.1.0.0/16",
            blocking=True,
            **salt_conn_parameters
        )["result"]["CidrBlockAssociation"]["AssociationId"]

        res = boto3_ec2.disassociate_vpc_cidr_block(
            association_id=association_id, blocking=True, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "associate_vpc_cidr_block",
            "disassociate_vpc_cidr_block",
            "describe_vpcs",
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv4_block_by_lookup_non_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv4 CIDR block from an existing VPC by using vpc_lookup.
        Non-blocking variant.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            cidr_block="10.1.0.0/16",
            blocking=True,
            **salt_conn_parameters
        )

        res = boto3_ec2.disassociate_vpc_cidr_block(
            vpc_lookup={"vpc_id": vpc_id, "cidr_block": "10.1.0.0/16"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "associate_vpc_cidr_block",
            "disassociate_vpc_cidr_block",
            "describe_vpcs",
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv4_block_by_lookup_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv4 CIDR block from an existing VPC by using vpc_lookup.
        Blocking variant.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            cidr_block="10.1.0.0/16",
            blocking=True,
            **salt_conn_parameters
        )

        res = boto3_ec2.disassociate_vpc_cidr_block(
            vpc_lookup={"vpc_id": vpc_id, "cidr_block": "10.1.0.0/16"},
            blocking=True,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv6_block_by_association_id_non_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv6 CIDR block from an existing VPC by providing the association_id.
        Non-blocking variant.
        """
        vpc_id = self._create_vpc()
        association_id = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            amazon_provided_ipv6_cidr_block=True,
            blocking=True,
            **salt_conn_parameters
        )["result"]["Ipv6CidrBlockAssociation"]["AssociationId"]

        res = boto3_ec2.disassociate_vpc_cidr_block(
            association_id=association_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv6_block_by_association_id_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv6 CIDR block from an existing VPC by providing the association_id.
        Blocking variant.
        """
        vpc_id = self._create_vpc()
        association_id = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            amazon_provided_ipv6_cidr_block=True,
            blocking=True,
            **salt_conn_parameters
        )["result"]["Ipv6CidrBlockAssociation"]["AssociationId"]

        res = boto3_ec2.disassociate_vpc_cidr_block(
            association_id, blocking=True, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "associate_vpc_cidr_block", "disassociate_vpc_cidr_block"
        )
    )
    def test_disassociate_vpc_cidr_block_with_ipv6_block_by_ipv6_cidr_block_non_blocking_succeeds(
        self,
    ):
        """
        Tests succesful disassociating an added IPv6 CIDR block from an existing VPC by using vpc_lookup.
        Non-blocking variant.
        """
        vpc_id = self._create_vpc()
        ipv6_cidr_block = boto3_ec2.associate_vpc_cidr_block(
            vpc_id=vpc_id,
            amazon_provided_ipv6_cidr_block=True,
            blocking=True,
            **salt_conn_parameters
        )["result"]["Ipv6CidrBlockAssociation"]["Ipv6CidrBlock"]

        res = boto3_ec2.disassociate_vpc_cidr_block(
            vpc_lookup={"ipv6_cidr_block": ipv6_cidr_block}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
@skipIf(
    _has_required_moto() is False,
    "The moto version must be >= to version {}".format(required_moto_version),
)
class BotoVpcSubnetTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    # create_subnet tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_subnet"))
    def test_create_subnet_without_vpc_raises_error(
        self,
    ):
        """
        Tests creating a subnet without specifying a VPC (required) raising an error.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.create_subnet(cidr_block="10.0.0.0/24", **salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet"))
    def test_create_subnet_with_vpc_by_id_succesfully_returns_true(
        self,
    ):
        """
        Tests creating a subnet successfully.
        VPC is specified by ID.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24", vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertTrue(res["result"])
        self.assertTrue("SubnetId" in res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_vpcs"))
    def test_create_subnet_with_vpc_by_lookup_succesfully_returns_true(
        self,
    ):
        """
        Tests creating a subnet successfully.
        VPC is specified by Name-tag.
        """
        self._create_vpc(name="test")

        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24",
            vpc_lookup={"vpc_name": "test"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertTrue(res["result"])
        self.assertTrue("SubnetId" in res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_subnet"))
    def test_create_subnet_with_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests creating a subnet in a non-existing VPC returns error.
        VPC is specified by ID.
        """
        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24", vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet"))
    def test_create_subnet_with_name_tag_succeeds(
        self,
    ):
        """
        Tests creating a subnet successfully when specifying a name.
        VPC is specified by ID.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24",
            vpc_id=vpc_id,
            tags={"Name": "test"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Tags", res["result"])
        self.assertEqual([{"Key": "Name", "Value": "test"}], res["result"]["Tags"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet"))
    def test_create_subnet_with_custom_tag_succeeds(
        self,
    ):
        """
        Tests creating a subnet successfully when specifying a tag.
        VPC is specified by ID.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24",
            vpc_id=vpc_id,
            tags={"test": "testvalue"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Tags", res["result"])
        self.assertEqual([{"Key": "test", "Value": "testvalue"}], res["result"]["Tags"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet"))
    def test_create_subnet_with_forced_error_handles_error_correctly(
        self,
    ):
        """
        Tests create_subnet handling ClientError correctly.
        """
        vpc_id = self._create_vpc()
        patch_function = "create_subnet"
        with patch(
            "moto.ec2.ec2_backend.{}".format(patch_function),
            side_effect=ClientError(self.mock_error, patch_function),
        ):

            res = boto3_ec2.create_subnet(
                cidr_block="10.0.0.0/24", vpc_id=vpc_id, **salt_conn_parameters
            )
        self.assertEqual(res, {"error": self.mock_errormessage.format(patch_function)})

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet"))
    def test_create_subnet_with_availability_zone_succeeds(self):
        """
        Tests that the availability_zone kwarg is passed on to _create_resource
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24",
            vpc_id=vpc_id,
            availability_zone="eu-west-1b",
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual("eu-west-1b", res["result"]["AvailabilityZone"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet"))
    def test_create_subnet_with_ipv6_block_succeeds(self):
        """
        Tests create_subnet with an IPv6 CIDR block specified by ipv6_subnet.
        """
        vpc_id = self._create_vpc(ipv6=True)

        res = boto3_ec2.create_subnet(
            cidr_block="10.0.0.0/24",
            ipv6_subnet=1,
            vpc_id=vpc_id,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Ipv6CidrBlockAssociationSet", res["result"])
        # self.assertEqual(1, len(res['result']['Ipv6CidrBlockAssociationSet']))  # Bug in Moto: doesn't assign provided Ipv6CidrBlock to subnet.

    # delete_subnet tests
    @mock_ec2
    @skipIf(*_moto_cannot("delete_subnet"))
    def test_delete_subnet_without_arguments_raises_error(
        self,
    ):
        """
        Tests delete_subnet without specifying anything raises an error.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A subnet is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.delete_subnet(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("delete_subnet"))
    def test_delete_subnet_by_id_with_non_existing_subnet_returns_error(
        self,
    ):
        """
        Tests deleting a subnet that doesn't exist
        """
        delete_subnet_result = boto3_ec2.delete_subnet(
            subnet_id="1234", **salt_conn_parameters
        )
        log.debug(
            "test_that_when_deleting_a_non_existent_subnet_the_delete_vpc_method_returns_false\n"
            "\t\tres: %s",
            delete_subnet_result,
        )
        self.assertTrue("error" in delete_subnet_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "delete_subnet"))
    def test_delete_subnet_by_id_with_existing_subnet_returns_true(
        self,
    ):
        """
        Tests deleting an existing subnet
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.delete_subnet(subnet_id=subnet_id, **salt_conn_parameters)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "create_subnet", "delete_subnet", "describe_subnets"
        )
    )
    def test_delete_subnet_by_lookup_with_existing_subnet_returns_true(
        self,
    ):
        """
        Tests deleting an existing subnet by Name-tag
        """
        vpc_id = self._create_vpc()
        self._create_subnet(vpc_id, name="test_subnet")

        res = boto3_ec2.delete_subnet(
            subnet_lookup={"subnet_name": "test_subnet"}, **salt_conn_parameters
        )
        self.assertEqual(True, res["result"])

    # describe_subnets tests
    @mock_ec2
    @skipIf(*_moto_cannot("describe_subnets"))
    def test_describe_subnets_by_id_for_non_existent_subnet_returns_error(self):
        """
        Tests describing a non-existent subnet by id.
        """
        res = boto3_ec2.describe_subnets(subnet_ids="fake", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertIn("The subnet ID '{'fake'}' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_describe_subnets_by_id_for_existing_subnet_returns_correct_data(self):
        """
        Tests describing a subnet by id.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.describe_subnets(subnet_ids=subnet_id, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertLessEqual(
            {"SubnetId", "CidrBlock", "AvailabilityZone"},
            set(res["result"][0].keys()),
        )
        self.assertEqual(res["result"][0]["SubnetId"], subnet_id)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_describe_subnets_by_name_for_existing_subnet_returns_correct_data(
        self,
    ):
        """
        Tests describing a subnet by name.
        """
        vpc_id = self._create_vpc()
        self._create_subnet(vpc_id, name="test")

        res = boto3_ec2.describe_subnets(
            filters={"tag:Name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertLessEqual(
            {"SubnetId", "CidrBlock", "AvailabilityZone", "Tags"},
            set(res["result"][0].keys()),
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_subnets"))
    def test_describe_subnets_by_name_for_non_existent_subnet_returns_empty(self):
        """
        Tests describing a non-existent subnet by id.
        """
        self._create_vpc()

        res = boto3_ec2.describe_subnets(
            filters={"tag:Name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(res["result"], [])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_describe_subnets_by_id_for_multiple_existing_subnet_returns_the_data_for_both_subnets(
        self,
    ):
        """
        Tests describing multiple subnets by id.
        """
        vpc_id = self._create_vpc()
        subnet1_id = self._create_subnet(vpc_id, cidr_block="10.0.1.0/24")
        subnet2_id = self._create_subnet(vpc_id, cidr_block="10.0.2.0/24")

        res = boto3_ec2.describe_subnets(
            subnet_ids=[subnet1_id, subnet2_id], **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(len(res["result"]), 2)
        self.assertLessEqual(
            {"SubnetId", "CidrBlock", "AvailabilityZone", "State"},
            set(res["result"][0].keys()),
        )

    # lookup_subnet tests
    @mock_ec2
    @skipIf(*_moto_cannot("describe_subnets"))
    def test_lookup_subnet_by_id_with_non_existing_subnet_returns_error(
        self,
    ):
        """
        Tests looking up a non-existing subnet by subnet_id returning error.
        """
        res = boto3_ec2.lookup_subnet(subnet_id="fake", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual(res["error"], "No subnet found with the specified parameters")

    @mock_ec2
    @skipIf(*_moto_cannot("describe_subnets"))
    def test_lookup_subnet_by_name_with_non_existing_subnet_returns_error(
        self,
    ):
        """
        Tests checking subnet existence by name when it doesn't exist
        """
        res = boto3_ec2.lookup_subnet(subnet_name="test", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual(res["error"], "No subnet found with the specified parameters")

    @mock_ec2
    @skipIf(*_moto_cannot("describe_subnets"))
    def test_lookup_subnet_by_custom_tag_with_non_existing_subnet_returns_error(
        self,
    ):
        """
        Tests checking subnet existence by tag when subnet doesn't exist
        """
        res = boto3_ec2.lookup_subnet(
            tags={"test": "testvalue"}, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(res["error"], "No subnet found with the specified parameters")

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "create_subnet", "describe_subnets", "describe_vpcs"
        )
    )
    def test_lookup_subnet_by_id_with_vpc_id_with_existing_subnet_but_incorrect_vpc_id_returns_error(
        self,
    ):
        """
        Tests looking up a subnet by subnet_id and vpc_lookup succesfully.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.lookup_subnet(
            subnet_id=subnet_id, vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_lookup_subnet_by_id_with_existing_subnet_returns_it(
        self,
    ):
        """
        Tests looking up a subnet by subnet_id succesfully.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.lookup_subnet(subnet_id=subnet_id, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertIn("SubnetId", res["result"])
        self.assertEqual(subnet_id, res["result"]["SubnetId"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "create_subnet", "describe_subnets", "describe_vpcs"
        )
    )
    def test_lookup_subnet_by_id_with_vpc_lookup_by_name_with_existing_subnet_returns_it(
        self,
    ):
        """
        Tests looking up a subnet by subnet_id and vpc_lookup succesfully.
        """
        vpc_id = self._create_vpc(name="test_vpc")
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.lookup_subnet(
            subnet_id=subnet_id,
            vpc_lookup={"vpc_name": "test_vpc"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("SubnetId", res["result"])
        self.assertEqual(subnet_id, res["result"]["SubnetId"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_lookup_subnet_by_name_with_existing_subnet_returns_it(
        self,
    ):
        """
        Tests checking subnet existence by name
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id, name="test")

        res = boto3_ec2.lookup_subnet(subnet_name="test", **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertLessEqual(
            {"SubnetId", "CidrBlock", "AvailabilityZone", "State"},
            set(res["result"].keys()),
        )
        self.assertEqual(res["result"]["SubnetId"], subnet_id)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_lookup_subnet_by_custom_tag_with_existing_subnet_returns_it(
        self,
    ):
        """
        Tests checking subnet existence by tag
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id, tags={"test": "testvalue"})

        res = boto3_ec2.lookup_subnet(
            tags={"test": "testvalue"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("SubnetId", res["result"])
        self.assertEqual(res["result"]["SubnetId"], subnet_id)

    # associate_subnet_cidr_block tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_associate_subnet_cidr_block_without_target_subnet_raises_error(
        self,
    ):
        """
        Tests associate_subnet_cidr_block without targeting arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A subnet is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.associate_subnet_cidr_block(ipv6_subnet=1, **salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_associate_subnet_cidr_block_without_ipv6_cidr_block_or_ipv6_subnet_raises_error(
        self,
    ):
        """
        Tests associate_subnet_cidr_block without ipv6_cidr_block or ipv6_subnet arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            'You must specify exactly one of "ipv6_cidr_block" or "ipv6_subnet".',
        ):
            boto3_ec2.associate_subnet_cidr_block(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("associate_subnet_cidr_block"))
    def test_associate_subnet_cidr_block_on_non_existing_subnet_returns_error(
        self,
    ):
        """
        Tests associate_subnet_cidr_block to non-existing subnet returns error.
        """
        res = boto3_ec2.associate_subnet_cidr_block(
            subnet_id="fake", ipv6_subnet=1, **salt_conn_parameters
        )
        self.assertIn("error", res)
        # self.assertIn('InvalidSubnetID.NotFound', res['error'])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "associate_subnet_cidr_block"))
    def test_associate_subnet_cidr_block_on_existing_subnet_by_id_succeeds(
        self,
    ):
        """
        Tests associate_subnet_cidr_block to existing subnet succeeds.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.associate_subnet_cidr_block(
            subnet_id=subnet_id, ipv6_subnet=1, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Ipv6CidrBlockAssociation", res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "associate_subnet_cidr_block"))
    def test_associate_subnet_cidr_block_multiple_times_on_existing_subnet_by_id_returns_error(
        self,
    ):
        """
        Tests associate_subnet_cidr_block to existing subnet two times fails the 2nd time.
        Since only one IPv6 CIDR block is allowed to be associated with a subnet.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)
        boto3_ec2.associate_subnet_cidr_block(
            subnet_id=subnet_id, ipv6_subnet=1, **salt_conn_parameters
        )

        res = boto3_ec2.associate_subnet_cidr_block(
            subnet_id=subnet_id, ipv6_subnet=2, **salt_conn_parameters
        )
        self.assertIn("error", res)

    # disassociate_subnet_cidr_block tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_disassociate_subnet_cidr_block_without_arguments_raises_error(
        self,
    ):
        """
        Tests disassociate_subnet_cidr_block without targeting arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A subnet is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.disassociate_subnet_cidr_block(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "describe_subnets"))
    def test_disassociate_subnet_cidr_block_from_subnet_by_id_which_has_none_returns_error(
        self,
    ):
        """
        Tests disassociate_subnet_cidr_block on subnet (by ID) that has no IPv6 CIDR block associated.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.disassociate_subnet_cidr_block(
            subnet_id=subnet_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "The subnet specified does not have an IPv6 CIDR block association.",
            res["error"],
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "associate_subnet_cidr_block"))
    def test_disassociate_subnet_cidr_block_from_subnet_by_id_which_has_different_cidr_block_returns_error(
        self,
    ):
        """
        Tests disassociate_subnet_cidr_block on subnet (by ID) that has a different IPv6 CIDR block associated.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)
        ipv6_cidr_block = boto3_ec2.associate_subnet_cidr_block(
            subnet_id=subnet_id, ipv6_subnet=1, **salt_conn_parameters
        )["result"]["Ipv6CidrBlockAssociation"]["Ipv6CidrBLock"]
        ipv6_cidr_block[-6] = "2"

        res = boto3_ec2.disassociate_subnet_cidr_block(
            subnet_id=subnet_id, ipv6_cidr_block=ipv6_cidr_block, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "The subnet does not have the specified IPv6 CIDR block associated.",
            res["error"],
        )

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_subnet",
            "associate_subnet_cidr_block",
            "disassociate_subnet_cidr_block",
        )
    )
    def test_disassociate_subnet_cidr_block_on_existing_subnet_by_association_id_succeeds(
        self,
    ):
        """
        Tests disassociate_subnet_cidr_block with association_id succeeds.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)
        association_id = boto3_ec2.associate_subnet_cidr_block(
            subnet_id=subnet_id, ipv6_subnet=1, **salt_conn_parameters
        )["result"]["Ipv6CidrBLockAssociation"]["AssociationId"]

        res = boto3_ec2.disassociate_subnet_cidr_block(
            association_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("Ipv6CidrBlockAssociation", res["result"])
        self.assertEqual({}, res["result"]["Ipv6CidrBlockAssociation"])

    # modify_subnet_attribute tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_modify_subnet_attribute_without_targeting_subnet_raises_error(
        self,
    ):
        """
        Tests modify_subnet_attribute without targeting arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A subnet is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.modify_subnet_attribute(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_modify_subnet_attribute_without_required_arguments_raises_error(
        self,
    ):
        """
        Tests modify_subnet_attribute with map_customer_owned_ip_on_launch but without customer_owned_ipv4_pool raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "Specifying map_customer_owned_ip_on_launch requires specifying customer_owned_ipv4_pool.",
        ):
            boto3_ec2.modify_subnet_attribute(
                map_customer_owned_ip_on_launch=True, **salt_conn_parameters
            )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "modify_subnet_attribute"))
    def test_modify_subnet_attribute_with_subnet_by_id_and_single_attribute_succeeds(
        self,
    ):
        """
        Tests modify_subnet_attribute on a subnet (by ID) and a single attribute.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.modify_subnet_attribute(
            subnet_id=subnet_id, map_public_ip_on_launch=True, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "modify_subnet_attribute"))
    def test_modify_subnet_attribute_with_subnet_by_id_and_multiple_attributes_succeeds(
        self,
    ):
        """
        Tests modify_subnet_attribute on a subnet (by ID) and multiple attributes.
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.modify_subnet_attribute(
            subnet_id=subnet_id,
            map_public_ip_on_launch=True,
            assign_ipv6_address_on_creation=True,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
class BotoVpcInternetGatewayTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    # create_internet_gateway tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway"))
    def test_create_internet_gateway_without_arguments_succeeds(
        self,
    ):
        """
        Tests creating an internet gateway successfully (with no vpc id or name)
        """
        res = boto3_ec2.create_internet_gateway(**salt_conn_parameters)
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway"))
    def test_create_internet_gateway_with_tags_succeeds(
        self,
    ):
        """
        Tests creating an internet gateway successfully (with no vpc id or name)
        """
        res = boto3_ec2.create_internet_gateway(
            tags={"Name": "test", "foo": "bar"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertIn("Tags", res["result"])
        self.assertEqual(
            [{"Key": "Name", "Value": "test"}, {"Key": "foo", "Value": "bar"}],
            res["result"]["Tags"],
        )

    # attach_internet_gateway tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_attach_internet_gateway_without_internet_gateway_raises_error(
        self,
    ):
        """
        Tests attach_internet_gateway without specifying an internet gateway raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A internet_gateway is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.attach_internet_gateway(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_attach_internet_gateway_without_vpc_raises_error(
        self,
    ):
        """
        Tests attach_internet_gateway, without specifying a VPC to attach to, raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.attach_internet_gateway(
                internet_gateway_id="fake", **salt_conn_parameters
            )

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "attach_internet_gateway"))
    def test_attach_internet_gateway_by_id_to_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests attaching a created internet gateway to a non-existing VPC (by ID) returns error.
        """
        igw_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)["result"][
            "InternetGatewayId"
        ]

        res = boto3_ec2.attach_internet_gateway(
            internet_gateway_id=igw_id, vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("InvalidVpcID.NotFound", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "attach_internet_gateway"))
    def test_attach_internet_gateway_by_non_existing_id_to_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests attaching a non-existing internet gateway to a VPC (by ID) returns error.
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.attach_internet_gateway(
            internet_gateway_id="fake", vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("InvalidInternetGatewayID.NotFound", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "attach_internet_gateway"))
    def test_attach_internet_gateway_by_id_to_vpc_by_id_succeeds(
        self,
    ):
        """
        Tests attaching a created internet gateway to a VPC (by ID) is succesful.
        """
        vpc_id = self._create_vpc()
        igw_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)["result"][
            "InternetGatewayId"
        ]

        res = boto3_ec2.attach_internet_gateway(
            internet_gateway_id=igw_id, vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "attach_internet_gateway"))
    def test_attach_internet_gateway_by_id_to_vpc_by_lookup_succeeds(
        self,
    ):
        """
        Tests attaching a created internet gateway to a VPC (by Name-tag) is succesful.
        """
        self._create_vpc(name="test_vpc")
        igw_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)["result"][
            "InternetGatewayId"
        ]

        res = boto3_ec2.attach_internet_gateway(
            internet_gateway_id=igw_id,
            vpc_lookup={"vpc_name": "test_vpc"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "attach_internet_gateway"))
    def test_attach_internet_gateway_by_lookup_to_vpc_by_id_succeeds(
        self,
    ):
        """
        Tests attaching a created internet gateway (by Name-tag) to a VPC (by ID) is succesful.
        """
        vpc_id = self._create_vpc(name="test_vpc")
        boto3_ec2.create_internet_gateway(
            tags={"Name": "test_igw"}, **salt_conn_parameters
        )

        res = boto3_ec2.attach_internet_gateway(
            internet_gateway_lookup={"internet_gateway_name": "test_igw"},
            vpc_id=vpc_id,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "create_internet_gateway", "attach_internet_gateway"
        )
    )
    def test_attach_internet_gateway_by_id_to_multiple_vpcs_by_id_returns_error(
        self,
    ):
        """
        Tests attaching a created internet gateway (by ID) to multiple VPCs (by ID) returns error.
        """
        vpc1_id = self._create_vpc()
        vpc2_id = self._create_vpc(cidr_block="10.1.0.0/16")
        igw_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)["result"][
            "InternetGatewayId"
        ]
        boto3_ec2.attach_internet_gateway(
            internet_gateway_id=igw_id, vpc_id=vpc1_id, **salt_conn_parameters
        )

        res = boto3_ec2.attach_internet_gateway(
            internet_gateway_id=igw_id, vpc_id=vpc2_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("Resource.AlreadyAssociated", res["error"])

    # create_and_attach_internet_gateway tests
    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "attach_internet_gateway"))
    def test_create_internet_gateway_attach_to_non_existing_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests that creating an internet gateway and attaching it to a non-existent VPC returns partial success (IGW creation) and error (attaching)
        """
        res = boto3_ec2.create_internet_gateway(vpc_id="fake", **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertIn("error", res)
        self.assertIn("InvalidVpcID.NotFound", res["error"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "attach_internet_gateway",
            "describe_internet_gateways",
        )
    )
    def test_create_internet_gateway_attach_to_vpc_by_id_succeeds(
        self,
    ):
        """
        Tests creating an internet gateway and attaching it to an existing VPC (by ID).
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.create_internet_gateway(vpc_id=vpc_id, **salt_conn_parameters)
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertIn("Attachments", res["result"])
        self.assertEqual(1, len(res["result"]["Attachments"]))
        self.assertIn("VpcId", res["result"]["Attachments"][0])
        self.assertEqual(vpc_id, res["result"]["Attachments"][0]["VpcId"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "attach_internet_gateway",
            "describe_internet_gateways",
        )
    )
    def test_create_internet_gateway_with_vpc_by_lookup_succeeds(
        self,
    ):
        """
        Tests creating an internet gateway and attaching it to an existing VPC (by Name-tag).
        """
        vpc_id = self._create_vpc(name="test")

        res = boto3_ec2.create_internet_gateway(
            vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertIn("Attachments", res["result"])
        self.assertEqual(1, len(res["result"]["Attachments"]))
        self.assertIn("VpcId", res["result"]["Attachments"][0])
        self.assertEqual(vpc_id, res["result"]["Attachments"][0]["VpcId"])

    # describe_internet_gateways tests
    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_describe_internet_gateways_without_arguments_with_no_igws_returns_empty(
        self,
    ):
        """
        Test that describe_internet_gateways without arguments returns all (currently none) IGWs.
        """
        res = boto3_ec2.describe_internet_gateways(**salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual([], res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "describe_internet_gateways"))
    def test_describe_internet_gateways_without_arguments_with_three_igws_returns_all(
        self,
    ):
        """
        Test that describe_internet_gateways without arguments returns all 3 IGWs.
        """
        boto3_ec2.create_internet_gateway(**salt_conn_parameters)
        boto3_ec2.create_internet_gateway(**salt_conn_parameters)
        boto3_ec2.create_internet_gateway(**salt_conn_parameters)

        res = boto3_ec2.describe_internet_gateways(**salt_conn_parameters)
        self.assertIn("result", res)
        self.assertEqual(3, len(res["result"]))

    # lookup_internet_gateway tests
    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_without_arguments_raises_error(self):
        """
        Test lookup_internet_gateway without arguments raises SaltInvocationError
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "No constraints where given for lookup_internet_gateway.",
        ):
            boto3_ec2.lookup_internet_gateway(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_non_existing_internet_gateway_by_id_returns_error(self):
        """
        Test lookup_internet_gateway with non-existing IGW by ID.
        """
        res = boto3_ec2.lookup_internet_gateway(
            internet_gateway_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_non_existing_internet_gateway_by_name_returns_error(self):
        """
        Test lookup_internet_gateway with non-existing IGW by name.
        """
        res = boto3_ec2.lookup_internet_gateway(
            internet_gateway_name="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_non_existing_internet_gateway_by_attachment_state_returns_error(
        self,
    ):
        """
        Test lookup_internet_gateway with non-existing IGW by attachment_state.
        """
        res = boto3_ec2.lookup_internet_gateway(
            attachment_state="detached", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_non_existing_internet_gateway_by_attachment_vpc_id_returns_error(
        self,
    ):
        """
        Test lookup_internet_gateway with non-existing IGW by attachment_vpc_id.
        """
        res = boto3_ec2.lookup_internet_gateway(
            attachment_vpc_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "describe_internet_gateways"))
    def test_lookup_non_existing_internet_gateway_by_attachment_vpc_lookup_returns_error(
        self,
    ):
        """
        Test lookup_internet_gateway with non-existing IGW by attachment_vpc_lookup.
        """
        self._create_vpc(name="test")

        res = boto3_ec2.lookup_internet_gateway(
            attachment_vpc_lookup={"vpc_name": "test"}, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_by_id_returns_it(self):
        """
        Test lookup_internet_gateway with an IGW by ID returns it.
        """
        internet_gateway_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)[
            "result"
        ]["InternetGatewayId"]

        res = boto3_ec2.lookup_internet_gateway(
            internet_gateway_id=internet_gateway_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertEqual(internet_gateway_id, res["result"]["InternetGatewayId"])

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_by_tag_returns_it(self):
        """
        Test lookup_internet_gateway with an IGW by tag returns it.
        """
        internet_gateway_id = boto3_ec2.create_internet_gateway(
            tags={"Name": "test"}, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.lookup_internet_gateway(
            internet_gateway_name="test", **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertEqual(internet_gateway_id, res["result"]["InternetGatewayId"])

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_by_attachment_state_with_detached_igw_returns_it(
        self,
    ):
        """
        Test lookup_internet_gateway with a detached IGW by attachment state returns it.
        """
        internet_gateway_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)[
            "result"
        ]["InternetGatewayId"]

        res = boto3_ec2.lookup_internet_gateway(
            attachment_state="detached", **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertEqual(internet_gateway_id, res["result"]["InternetGatewayId"])

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_by_attachment_state_with_attached_igw_returns_it(
        self,
    ):
        """
        Test lookup_internet_gateway with an attached IGW by attachment state returns it.
        """
        vpc_id = self._create_vpc()
        internet_gateway_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.lookup_internet_gateway(
            attachment_state="available", **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertEqual(internet_gateway_id, res["result"]["InternetGatewayId"])

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_by_attached_vpc_id_with_attached_igw_returns_it(
        self,
    ):
        """
        Test lookup_internet_gateway with an attached IGW by attached VPC id returns it.
        """
        vpc_id = self._create_vpc()
        internet_gateway_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.lookup_internet_gateway(
            attachment_vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertEqual(internet_gateway_id, res["result"]["InternetGatewayId"])

    @mock_ec2
    @skipIf(*_moto_cannot("describe_internet_gateways"))
    def test_lookup_internet_gateway_by_attached_vpc_lookup_with_attached_igw_returns_it(
        self,
    ):
        """
        Test lookup_internet_gateway with an attached IGW by attached VPC id returns it.
        """
        vpc_id = self._create_vpc(tags={"foo": "bar"})
        internet_gateway_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.lookup_internet_gateway(
            attachment_vpc_lookup={"tags": {"foo": "bar"}}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("InternetGatewayId", res["result"])
        self.assertEqual(internet_gateway_id, res["result"]["InternetGatewayId"])

    # detach_internet_gateway tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_detach_internet_gateway_without_arguments_raises_error(self):
        """
        Tests detach_internet_gateway without arguments raises a SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A vpc is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.detach_internet_gateway(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_detach_internet_gateway_without_internet_gateway_returns_error(self):
        """
        Tests detach_internet_gateway without internet_gateway returns an error.
        (It will attempt to lookup the IGW by attached vpc if vpc_id or vpc_lookup are specified)
        """
        res = boto3_ec2.detach_internet_gateway(vpc_id="fake", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("describe_vpcs", "describe_internet_gateways"))
    def test_detach_internet_gateway_by_nonexisting_id_from_nonexisting_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests detach_internet_gateway with non-existing igw and vpc returns error.
        """
        res = boto3_ec2.detach_internet_gateway(
            vpc_id="fake", internet_gateway_id="also_fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("InvalidInternetGatewayID.NotFound", res["error"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "describe_vpcs", "create_internet_gateway", "detach_internet_gateway"
        )
    )
    def test_detach_internet_gateway_by_id_from_nonexisting_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests detach_internet_gateway with igw (by ID) and non-existing vpc (by ID) returns error.
        """
        igw_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)["result"][
            "InternetGatewayId"
        ]

        res = boto3_ec2.detach_internet_gateway(
            vpc_id="fake", internet_gateway_id=igw_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("Gateway.NotAttached", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_internet_gateway", "describe_vpcs"))
    def test_detach_internet_gateway_by_id_from_nonexisting_vpc_by_lookup_returns_error(
        self,
    ):
        """
        Tests detach_internet_gateway with igw (by ID) and non-existing vpc (by Lookup) returns error.
        """
        igw_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)["result"][
            "InternetGatewayId"
        ]

        res = boto3_ec2.detach_internet_gateway(
            vpc_lookup={"vpc_name": "test"},
            internet_gateway_id=igw_id,
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "create_internet_gateway", "detach_internet_gateway"
        )
    )
    def test_detach_internet_gateway_by_id_from_vpc_by_id_succeeds(self):
        """
        Tests detach_internet_gateway with igw (by ID) from existing vpc (by ID) succeeds.
        """
        vpc_id = self._create_vpc()
        igw_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.detach_internet_gateway(
            vpc_id=vpc_id, internet_gateway_id=igw_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "describe_vpcs",
            "detach_internet_gateway",
        )
    )
    def test_detach_internet_gateway_by_id_from_vpc_by_lookup_succeeds(self):
        """
        Tests detach_internet_gateway with igw (by ID) from existing vpc (by lookup) succeeds.
        """
        vpc_id = self._create_vpc(name="test")
        igw_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.detach_internet_gateway(
            vpc_lookup={"vpc_name": "test"},
            internet_gateway_id=igw_id,
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "describe_internet_gateways",
            "detach_internet_gateway",
        )
    )
    def test_detach_internet_gateway_by_lookup_with_name_from_vpc_by_id_succeeds(self):
        """
        Tests detach_internet_gateway with igw (by lookup with name) from existing vpc (by ID) succeeds.
        """
        vpc_id = self._create_vpc()
        boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, tags={"Name": "test"}, **salt_conn_parameters
        )

        res = boto3_ec2.detach_internet_gateway(
            vpc_id=vpc_id,
            internet_gateway_lookup={"internet_gateway_name": "test"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "describe_internet_gateways",
            "detach_internet_gateway",
            "describe_vpcs",
        )
    )
    def test_detach_internet_gateway_by_lookup_with_attached_vpc_by_name_from_vpc_by_id_succeeds(
        self,
    ):
        """
        Tests detach_internet_gateway with igw (by lookup with attached vpc by name) from existing vpc (by ID) succeeds.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.create_internet_gateway(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.detach_internet_gateway(
            vpc_id=vpc_id,
            internet_gateway_lookup={"attachment_vpc_lookup": {"vpc_name": "test"}},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "describe_internet_gateways",
            "detach_internet_gateway",
            "describe_vpcs",
        )
    )
    def test_detach_internet_gateway_by_lookup_with_non_existing_attached_vpc_by_name_from_vpc_by_id_returns_error(
        self,
    ):
        """
        Tests detach_internet_gateway with igw (by lookup with attached vpc by name) from existing vpc (by ID) succeeds.
        """
        vpc_id = self._create_vpc(name="test")
        boto3_ec2.create_internet_gateway(vpc_id=vpc_id, **salt_conn_parameters)

        res = boto3_ec2.detach_internet_gateway(
            vpc_id=vpc_id,
            internet_gateway_lookup={
                "attachment_vpc_lookup": {"vpc_name": "doesnotexist"}
            },
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual("No vpc found with the specified parameters", res["error"])

    # delete_internet_gateway tests
    @mock_ec2
    @skipIf(*_moto_cannot())
    def test_delete_internet_gateway_without_arguments_raises_error(self):
        """
        Tests delete_internet_gateway without arguments raising SaltInvocationError.
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "A internet_gateway is required. Please specify either by ID or by lookup kwargs.",
        ):
            boto3_ec2.delete_internet_gateway(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("delete_internet_gateway"))
    def test_delete_internet_gateway_by_nonexisting_id_returns_error(self):
        """
        Tests delete_internet_gateway by nonexisting ID returns error.
        """
        res = boto3_ec2.delete_internet_gateway(
            internet_gateway_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("InvalidInternetGatewayID.NotFound", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("delete_internet_gateway", "describe_internet_gateways"))
    def test_delete_internet_gateway_by_nonexisting_lookup_returns_error(self):
        """
        Tests delete_internet_gateway by nonexisting lookup returns error.
        """
        res = boto3_ec2.delete_internet_gateway(
            internet_gateway_lookup={"internet_gateway_name": "test"},
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertEqual(
            "No internet_gateway found with the specified parameters", res["error"]
        )

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "delete_internet_gateway"))
    def test_delete_non_attached_internet_gateway_with_detach_option_succeeds(self):
        """
        Tests that the detach-option does not interfere with deleting a non-attached IGW.
        """
        internet_gateway_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)[
            "result"
        ]["InternetGatewayId"]

        res = boto3_ec2.delete_internet_gateway(
            internet_gateway_id=internet_gateway_id, detach=True, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_internet_gateway", "delete_internet_gateway"))
    def test_delete_internet_gateway_by_id_succeeds(self):
        """
        Tests delete_internet_gateway by ID.
        """
        internet_gateway_id = boto3_ec2.create_internet_gateway(**salt_conn_parameters)[
            "result"
        ]["InternetGatewayId"]

        res = boto3_ec2.delete_internet_gateway(
            internet_gateway_id=internet_gateway_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc", "create_internet_gateway", "delete_internet_gateway"
        )
    )
    def test_delete_attached_internet_gateway_by_id_returns_error(self):
        """
        Tests delete_internet_gateway with an attached igw by ID.
        """
        vpc_id = self._create_vpc()
        internet_gateway_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.delete_internet_gateway(
            internet_gateway_id=internet_gateway_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("DependencyViolation", res["error"])

    @mock_ec2
    @skipIf(
        *_moto_cannot(
            "create_vpc",
            "create_internet_gateway",
            "delete_internet_gateway",
            "describe_internet_gateways",
        )
    )
    def test_delete_attached_internet_gateway_by_id_with_detach_option_succeeds(self):
        """
        Tests delete_internet_gateway with an attached igw by ID.
        """
        vpc_id = self._create_vpc()
        internet_gateway_id = boto3_ec2.create_internet_gateway(
            vpc_id=vpc_id, **salt_conn_parameters
        )["result"]["InternetGatewayId"]

        res = boto3_ec2.delete_internet_gateway(
            internet_gateway_id=internet_gateway_id, detach=True, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(True, res["result"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
class BotoVpcNatGatewayTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "create_nat_gateway"))
    def test_that_when_creating_an_nat_gateway_the_create_nat_gateway_method_returns_true(
        self,
    ):
        """
        Tests creating an nat gateway successfully (with subnet_id specified)
        """

        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id, availability_zone="us-east-1a")
        res = boto3_ec2.create_nat_gateway(subnet_id=subnet_id, **salt_conn_parameters)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_nat_gateway"))
    def test_that_when_creating_an_nat_gateway_with_non_existent_subnet_the_create_nat_gateway_method_returns_an_error(
        self,
    ):
        """
        Tests that creating an nat gateway for a non-existent subnet fails.
        """

        ngw_creation_result = boto3_ec2.create_nat_gateway(
            subnet_id="non-existent-subnet", **salt_conn_parameters
        )
        self.assertTrue("error" in ngw_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc", "create_subnet", "create_nat_gateway"))
    def test_that_when_creating_an_nat_gateway_with_subnet_name_specified_the_create_nat_gateway_method_returns_true(
        self,
    ):
        """
        Tests creating an nat gateway with subnet name specified.
        """

        vpc_id = self._create_vpc()
        self._create_subnet(vpc_id, name="test-subnet", availability_zone="us-east-1a")
        res = boto3_ec2.create_nat_gateway(
            subnet_lookup={"subnet_name": "test-subnet"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("NatGatewayId", res["result"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
class BotoVpcCustomerGatewayTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    @mock_ec2
    @skipIf(*_moto_cannot("create_customer_gateway"))
    def test_that_when_creating_a_customer_gateway_the_create_customer_gateway_method_returns_true(
        self,
    ):
        """
        Tests creating an internet gateway successfully (with no vpc id or name)
        """

        res = boto3_ec2.create_customer_gateway(
            65000, "ipsec.1", public_ip="10.1.1.1", **salt_conn_parameters
        )
        self.assertTrue(res["result"])

    @mock_ec2
    def test_that_when_checking_if_a_cgw_exists_by_id_the_lookup_cgw_method_returns_true(
        self,
    ):
        """
        Tests checking if a customer gateway exists when it does exist
        """

        res = boto3_ec2.create_customer_gateway(
            65000,
            "ipsec.1",
            public_ip="10.1.1.1",
            tags={"Name": "test_cgw"},
            **salt_conn_parameters
        )
        self.assertIn("result", res)
        customer_gateway_id = res["result"]["CustomerGatewayId"]
        # Moto 1.3.14 does not support filters except filter-by-tags.
        res = boto3_ec2.lookup_customer_gateway(
            tags={"Name": "test_cgw"}, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("CustomerGatewayId", res["result"])
        self.assertEqual(res["result"]["CustomerGatewayId"], customer_gateway_id)

    @mock_ec2
    def test_that_when_a_cgw_does_not_exist_the_describe_cgw_method_returns_empty(
        self,
    ):
        """
        Tests checking if a subnet exists which doesn't exist
        """
        res = boto3_ec2.describe_customer_gateways(
            customer_gateway_ids="fake", **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertEqual(res["result"], [])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
@skipIf(
    _has_required_moto() is False,
    "The moto version must be >= to version {}".format(required_moto_version),
)
class BotoVpcDHCPOptionsTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    @mock_ec2
    @skipIf(*_moto_cannot("create_dhcp_options"))
    def test_that_when_creating_dhcp_options_succeeds_the_create_dhcp_options_method_returns_true(
        self,
    ):
        """
        Tests creating dhcp options successfully
        """
        res = boto3_ec2.create_dhcp_options(
            **dhcp_options_parameters, **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_dhcp_options"))
    def test_that_when_creating_dhcp_options_and_specifying_a_name_succeeds_the_create_dhcp_options_method_returns_true(
        self,
    ):
        """
        Tests creating dchp options with name successfully
        """
        res = boto3_ec2.create_dhcp_options(
            tags={"Name": "test"}, **dhcp_options_parameters, **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_dhcp_options"))
    def test_that_when_creating_dhcp_options_and_specifying_tags_succeeds_the_create_dhcp_options_method_returns_true(
        self,
    ):
        """
        Tests creating dchp options with tag successfully
        """
        res = boto3_ec2.create_dhcp_options(
            tags={"test": "testvalue"},
            **dhcp_options_parameters,
            **salt_conn_parameters
        )
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_dhcp_options"))
    def test_that_when_creating_dhcp_options_fails_the_create_dhcp_options_method_returns_error(
        self,
    ):
        """
        Tests creating dhcp options failure
        """
        patch_function = "create_dhcp_options"
        with patch(
            "moto.ec2.ec2_backend.{}".format(patch_function),
            side_effect=ClientError(self.mock_error, patch_function),
        ):
            res = boto3_ec2.create_dhcp_options(
                **dhcp_options_parameters, **salt_conn_parameters
            )
        self.assertEqual(res, {"error": self.mock_errormessage.format(patch_function)})

    @mock_ec2
    @skipIf(*_moto_cannot("associate_dhcp_options"))
    def test_that_when_associating_an_existing_dhcp_options_set_to_an_existing_vpc_the_associate_dhcp_options_method_returns_true(
        self,
    ):
        """
        Tests associating existing dchp options successfully
        """
        vpc_id = self._create_vpc()
        dhcp_options_id = self._create_dhcp_options()

        res = boto3_ec2.associate_dhcp_options(
            dhcp_options_id=dhcp_options_id, vpc_id=vpc_id, **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("associate_dhcp_options"))
    def test_that_when_associating_a_non_existent_dhcp_options_set_to_an_existing_vpc_the_associate_dhcp_options_method_returns_error(
        self,
    ):
        """
        Tests associating non-existanct dhcp options successfully
        """
        vpc_id = self._create_vpc()

        res = boto3_ec2.associate_dhcp_options(
            dhcp_options_id="fake", vpc_id=vpc_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("DhcpOptionID fake does not exist.", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("associate_dhcp_options"))
    def test_that_when_associating_an_existing_dhcp_options_set_to_a_non_existent_vpc_the_associate_dhcp_options_method_returns_false(
        self,
    ):
        """
        Tests associating existing dhcp options to non-existence vpc
        """
        dhcp_options_id = self._create_dhcp_options()

        res = boto3_ec2.associate_dhcp_options(
            dhcp_options_id=dhcp_options_id, vpc_id="fake", **salt_conn_parameters
        )

        self.assertTrue("error" in res)

    @mock_ec2
    @skipIf(*_moto_cannot("describe_dhcp_options"))
    def test_that_when_dhcp_options_exists_the_dhcp_options_exists_method_returns_true(
        self,
    ):
        """
        Tests existence of dhcp options successfully
        """
        dhcp_options_id = self._create_dhcp_options()

        res = boto3_ec2.describe_dhcp_options(
            dhcp_option_ids=dhcp_options_id, **salt_conn_parameters
        )
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("describe_dhcp_options"))
    def test_that_when_dhcp_options_do_not_exist_the_dhcp_options_exists_method_returns_false(
        self,
    ):
        """
        Tests existence of dhcp options failure
        """
        res = boto3_ec2.describe_dhcp_options("fake", **salt_conn_parameters)
        self.assertIn("error", res)
        self.assertIn("DhcpOptionID fake does not exist.", res["error"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
class BotoVpcNetworkACLTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl"))
    def test_that_when_creating_network_acl_for_an_existing_vpc_the_create_network_acl_method_returns_true(
        self,
    ):
        """
        Tests creation of network acl with existing vpc
        """
        vpc_id = self._create_vpc()

        network_acl_creation_result = boto3_ec2.create_network_acl(
            vpc_id=vpc_id, **salt_conn_parameters
        )

        self.assertTrue(network_acl_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl"))
    def test_that_when_creating_network_acl_for_an_existing_vpc_and_specifying_a_name_the_create_network_acl_method_returns_true(
        self,
    ):
        """
        Tests creation of network acl via name with an existing vpc
        """
        vpc_id = self._create_vpc()

        network_acl_creation_result = boto3_ec2.create_network_acl(
            vpc_id, tags={"Name": "test"}, **salt_conn_parameters
        )

        self.assertTrue(network_acl_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl"))
    def test_that_when_creating_network_acl_for_an_existing_vpc_and_specifying_tags_the_create_network_acl_method_returns_true(
        self,
    ):
        """
        Tests creation of network acl via tags with an existing vpc
        """
        vpc_id = self._create_vpc()

        network_acl_creation_result = boto3_ec2.create_network_acl(
            vpc_id=vpc_id, tags={"test": "testvalue"}, **salt_conn_parameters
        )

        self.assertTrue(network_acl_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl"))
    def test_that_when_creating_network_acl_for_a_non_existent_vpc_the_create_network_acl_method_returns_an_error(
        self,
    ):
        """
        Tests creation of network acl with a non-existent vpc
        """
        network_acl_creation_result = boto3_ec2.create_network_acl(
            vpc_id="fake", **salt_conn_parameters
        )

        self.assertTrue("error" in network_acl_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl"))
    def test_that_when_creating_network_acl_fails_the_create_network_acl_method_returns_false(
        self,
    ):
        """
        Tests creation of network acl failure
        """
        vpc_id = self._create_vpc()

        patch_function = "create_network_acl"
        with patch(
            "moto.ec2.ec2_backend.{}".format(patch_function),
            side_effect=ClientError(self.mock_error, patch_function),
        ):
            res = boto3_ec2.create_network_acl(vpc_id=vpc_id, **salt_conn_parameters)
        self.assertEqual(res, {"error": self.mock_errormessage.format(patch_function)})

    @mock_ec2
    @skipIf(*_moto_cannot("delete_network_acl"))
    def test_that_when_deleting_an_existing_network_acl_the_delete_network_acl_method_returns_true(
        self,
    ):
        """
        Tests deletion of existing network acl successfully
        """
        vpc_id = self._create_vpc()
        network_acl_id = self._create_network_acl(vpc_id)

        res = boto3_ec2.delete_network_acl(
            network_acl_id=network_acl_id, **salt_conn_parameters
        )

        self.assertTrue(res)

    @mock_ec2
    @skipIf(*_moto_cannot("delete_network_acl"))
    def test_that_when_deleting_a_non_existent_network_acl_the_delete_network_acl_method_returns_an_error(
        self,
    ):
        """
        Tests deleting a non-existent network acl
        """
        network_acl_deletion_result = boto3_ec2.delete_network_acl(
            network_acl_id="fake", **salt_conn_parameters
        )

        self.assertTrue("error" in network_acl_deletion_result)

    @mock_ec2
    def test_that_when_a_network_acl_exists_the_lookup_network_acl_method_returns_it(
        self,
    ):
        """
        Tests existence of network acl
        """
        vpc_id = self._create_vpc()
        network_acl_id = self._create_network_acl(vpc_id, tags={"Name": "testacl"})

        # Moto 1.13.14 does not implement the network-acl-id filter, lookup by tag instead.
        res = boto3_ec2.lookup_network_acl(
            tags={"Name": "testacl"}, **salt_conn_parameters
        )

        self.assertIn("result", res)
        self.assertEqual(res["result"]["NetworkAclId"], network_acl_id)

    @mock_ec2
    def test_that_when_a_network_acl_does_not_exist_the_network_acl_exists_method_returns_false(
        self,
    ):
        """
        Tests checking network acl does not exist
        """
        res = boto3_ec2.lookup_network_acl(
            tags={"Name": "fake"}, **salt_conn_parameters
        )

        self.assertIn("error", res)
        self.assertEqual(
            res["error"], "No network_acl found with the specified parameters"
        )

    @mock_ec2
    def test_that_when_checking_if_network_acl_exists_but_providing_no_filters_the_network_acl_exists_method_raises_a_salt_invocation_error(
        self,
    ):
        """
        Tests checking existence of network acl with no filters
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "No constraints where given when for lookup_network_acl.",
        ):
            boto3_ec2.lookup_network_acl(**salt_conn_parameters)

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl_entry"))
    def test_that_when_creating_a_network_acl_entry_successfully_the_create_network_acl_entry_method_returns_true(
        self,
    ):
        """
        Tests creating network acl successfully
        """
        vpc_id = self._create_vpc()
        network_acl_id = self._create_network_acl(vpc_id)

        params = dict(self.network_acl_entry_parameters)
        params.update({"network_acl_id": network_acl_id})
        network_acl_entry_creation_result = boto3_ec2.create_network_acl_entry(
            **params, **salt_conn_parameters
        )

        self.assertTrue(network_acl_entry_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl_entry"))
    def test_that_when_creating_a_network_acl_entry_for_a_non_existent_network_acl_the_create_network_acl_entry_method_returns_false(
        self,
    ):
        """
        Tests creating network acl entry for non-existent network acl
        """
        res = boto3_ec2.create_network_acl_entry(
            **self.network_acl_entry_parameters, **salt_conn_parameters
        )

        self.assertIn("error", res)
        self.assertIn("The network acl ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("replace_network_acl_entry"))
    def test_that_when_replacing_a_network_acl_entry_successfully_the_replace_network_acl_entry_method_returns_true(
        self,
    ):
        """
        Tests replacing network acl entry successfully
        """
        vpc_id = self._create_vpc()
        network_acl_id = self._create_network_acl(vpc_id)
        params = dict(self.network_acl_entry_parameters)
        params.update({"network_acl_id": network_acl_id})
        self._create_network_acl_entry(**params)

        res = boto3_ec2.replace_network_acl_entry(**params, **salt_conn_parameters)

        self.assertIn("result", res)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_network_acl_entry"))
    def test_that_when_replacing_a_network_acl_entry_for_a_non_existent_network_acl_the_replace_network_acl_entry_method_returns_false(
        self,
    ):
        """
        Tests replacing a network acl entry for a non-existent network acl
        """
        res = boto3_ec2.create_network_acl_entry(
            **self.network_acl_entry_parameters, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("The network acl ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("delete_network_acl_entry"))
    def test_that_when_deleting_an_existing_network_acl_entry_the_delete_network_acl_entry_method_returns_true(
        self,
    ):
        """
        Tests deleting existing network acl entry successfully
        """
        vpc_id = self._create_vpc()
        network_acl_id = self._create_network_acl(vpc_id)
        params = dict(self.network_acl_entry_parameters)
        params.update({"network_acl_id": network_acl_id})
        self._create_network_acl_entry(**params)

        res = boto3_ec2.delete_network_acl_entry(
            100, True, network_acl_id=network_acl_id, **salt_conn_parameters
        )  # TODO: Make bugreport to moto: deleting network acl entries that do not exist is not handled properly

        self.assertIn("result", res)
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("delete_network_acl_entry"))
    def test_that_when_deleting_a_non_existent_network_acl_entry_the_delete_network_acl_entry_method_returns_false(
        self,
    ):
        """
        Tests deleting a non-existent network acl entry
        """
        res = boto3_ec2.delete_network_acl_entry(
            100, False, network_acl_id="fake", **salt_conn_parameters
        )

        self.assertIn("error", res)
        self.assertIn("The network acl ID 'fake' does not exist", res["error"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
class BotoVpcRouteTablesTestCase(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    @mock_ec2
    @skipIf(*_moto_cannot("create_route_table"))
    def test_that_when_creating_a_route_table_succeeds_the_create_route_table_method_returns_true(
        self,
    ):
        """
        Tests creating route table successfully
        """
        vpc_id = self._create_vpc()

        route_table_creation_result = boto3_ec2.create_route_table(
            vpc_id=vpc_id, **salt_conn_parameters
        )

        self.assertTrue(route_table_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("create_route_table"))
    def test_that_when_creating_a_route_table_on_a_non_existent_vpc_the_create_route_table_method_returns_false(
        self,
    ):
        """
        Tests creating route table on a non-existent vpc
        """
        route_table_creation_result = boto3_ec2.create_route_table(
            vpc_id="fake", **salt_conn_parameters
        )

        self.assertTrue(route_table_creation_result)

    @mock_ec2
    @skipIf(*_moto_cannot("delete_route_table"))
    def test_that_when_deleting_a_route_table_succeeds_the_delete_route_table_method_returns_true(
        self,
    ):
        """
        Tests deleting route table successfully
        """
        vpc_id = self._create_vpc()
        route_table_id = self._create_route_table(vpc_id)

        route_table_deletion_result = boto3_ec2.delete_route_table(
            route_table_id=route_table_id, **salt_conn_parameters
        )

        self.assertTrue(route_table_deletion_result)

    @mock_ec2
    @skipIf(*_moto_cannot("delete_route_table"))
    def test_that_when_deleting_a_non_existent_route_table_the_delete_route_table_method_returns_false(
        self,
    ):
        """
        Tests deleting non-existent route table
        """
        res = boto3_ec2.delete_route_table(
            route_table_id="fake", **salt_conn_parameters
        )

        self.assertIn("error", res)

    @mock_ec2
    def test_that_when_route_table_exists_the_route_table_exists_method_returns_true(
        self,
    ):
        """
        Tests existence of route table success
        """
        vpc_id = self._create_vpc()
        route_table_id = self._create_route_table(vpc_id)

        res = boto3_ec2.describe_route_tables(
            route_table_ids=route_table_id, **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    def test_that_when_route_table_does_not_exist_the_route_table_exists_method_returns_false(
        self,
    ):
        """
        Tests existence of route table failure
        """
        res = boto3_ec2.describe_route_tables(
            route_table_ids="fake", **salt_conn_parameters
        )

        self.assertIn("error", res)
        self.assertIn("The routeTable ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("associate_route_table"))
    def test_that_when_associating_a_route_table_succeeds_the_associate_route_table_method_should_return_the_association_id(
        self,
    ):
        """
        Tests associating route table successfully
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)
        route_table_id = self._create_route_table(vpc_id)

        res = boto3_ec2.associate_route_table(
            route_table_id=route_table_id, subnet_id=subnet_id, **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("associate_route_table"))
    def test_that_when_associating_a_route_table_with_a_non_existent_route_table_the_associate_route_table_method_should_return_false(
        self,
    ):
        """
        Tests associating of route table to non-existent route table
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)

        res = boto3_ec2.associate_route_table(
            route_table_id="fake", subnet_id=subnet_id, **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("The routeTable ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("associate_route_table"))
    def test_that_when_associating_a_route_table_with_a_non_existent_subnet_the_associate_route_table_method_should_return_false(
        self,
    ):
        """
        Tests associating of route table with non-existent subnet
        """
        vpc_id = self._create_vpc()
        route_table_id = self._create_route_table(vpc_id)

        res = boto3_ec2.associate_route_table(
            route_table_id=route_table_id, subnet_id="fake", **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("The subnet ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("disassociate_route_table"))
    def test_that_when_disassociating_a_route_table_succeeds_the_disassociate_route_table_method_should_return_true(
        self,
    ):
        """
        Tests disassociation of a route
        """
        vpc_id = self._create_vpc()
        subnet_id = self._create_subnet(vpc_id)
        route_table_id = self._create_route_table(vpc_id)
        association_id = self._associate_route_table(route_table_id, subnet_id)

        res = boto3_ec2.disassociate_route_table(
            association_id=association_id, **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_route_table"))
    def test_that_when_creating_a_route_succeeds_the_create_route_method_should_return_true(
        self,
    ):
        """
        Tests successful creation of a route
        """
        vpc_id = self._create_vpc()
        route_table_id = self._create_route_table(vpc_id)

        res = boto3_ec2.create_route(
            route_table_id=route_table_id,
            destination_cidr_block=self.cidr_block,
            **salt_conn_parameters
        )

        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("create_route"))
    def test_that_when_creating_a_route_with_a_non_existent_route_table_the_create_route_method_should_return_false(
        self,
    ):
        """
        Tests creation of route on non-existent route table
        """
        res = boto3_ec2.create_route(
            route_table_id="fake",
            destination_cidr_block=self.cidr_block,
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("The routeTable ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("delete_route"))
    def test_that_when_deleting_a_route_succeeds_the_delete_route_method_should_return_true(
        self,
    ):
        """
        Tests deleting route from route table
        """
        vpc_id = self._create_vpc()
        route_table_id = self._create_route_table(vpc_id)

        res = boto3_ec2.delete_route(
            route_table_id=route_table_id,
            destination_cidr_block=self.cidr_block,
            **salt_conn_parameters
        )
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("delete_route"))
    def test_that_when_deleting_a_route_with_a_non_existent_route_table_the_delete_route_method_should_return_false(
        self,
    ):
        """
        Tests deleting route from a non-existent route table
        """
        res = boto3_ec2.delete_route(
            route_table_id="fake",
            destination_cidr_block=self.cidr_block,
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("The routeTable ID 'fake' does not exist", res["error"])

    @mock_ec2
    @skipIf(*_moto_cannot("replace_route"))
    def test_that_when_replacing_a_route_succeeds_the_replace_route_method_should_return_true(
        self,
    ):
        """
        Tests replacing route successfully
        """
        vpc_id = self._create_vpc()
        route_table_id = self._create_route_table(vpc_id)

        res = boto3_ec2.replace_route(
            route_table_id=route_table_id,
            destination_cidr_block=self.cidr_block,
            **salt_conn_parameters
        )
        self.assertTrue(res["result"])

    @mock_ec2
    @skipIf(*_moto_cannot("replace_route"))
    def test_that_when_replacing_a_route_with_a_non_existent_route_table_the_replace_route_method_should_return_false(
        self,
    ):
        """
        Tests replacing a route when the route table doesn't exist
        """
        res = boto3_ec2.replace_route(
            route_table_id="fake",
            destination_cidr_block=self.cidr_block,
            **salt_conn_parameters
        )
        self.assertIn("error", res)
        self.assertIn("The routeTable ID 'fake' does not exist", res["error"])


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto module must be greater than"
    " or equal to version {}. Installed: {}".format(
        required_boto_version, _get_boto_version()
    ),
)
@skipIf(
    _has_required_moto() is False,
    "The moto version must be >= to version {}".format(required_moto_version),
)
class BotoVpcPeeringConnectionsTest(BotoVpcTestCaseBase, BotoVpcTestCaseMixin):
    @mock_ec2
    @skipIf(*_moto_cannot("create_vpc_peering_connection"))
    def test_request_vpc_peering_connection(self):
        """
        Run with 2 vpc ids and returns a message
        """
        my_vpc_id = self._create_vpc()
        other_vpc_id = self._create_vpc()
        res = boto3_ec2.create_vpc_peering_connection(
            requester_vpc_id=my_vpc_id, peer_vpc_id=other_vpc_id, **salt_conn_parameters
        )
        self.assertIn("result", res)
        self.assertIn("VpcPeeringConnectionId", res["result"])
